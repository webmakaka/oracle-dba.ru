---
layout: page
title: Структуры памяти Oracle
permalink: /docs/architecture/memory/
---

# Структуры памяти Oracle

    SQL> SELECT component, current_size, min_size, max_size
    FROM v$sga_dynamic_components;

<br/>

    SQL> SELECT name, value
    FROM v$pgastat
    WHERE name in ('maximum PGA allocated','total PGA allocated');

Oracle использует часть выделенной ему памяти для хранения как кода программ, так и данных, что позволяет существенно ускорить обработку, чем если бы пришлось постоянно извлекать данные с диска. Эти структуры памяти позволяют Oracle разделять один и тот же исполняемый код между несколькими пользователями, не тратя времени на подготовительные процедуры перед вызовом каждой порции кода.

Сервер Oracle не всегда пишет данные на диск непосредственно. Он пишет изменения базы данных в область памяти, и когда наступает подходящий момент, сбрасывает их на диск. Поскольку обращение к памяти происходит во много раз быстрее, чем к физическим дискам (оно измеряется наносекундами, в то время как обращение к диску – миллесекундами). Oracle может преодолеть ограничения ввода-вывода дисковой системы. Чем больше работы выполняет ваша база данных в памяти по сравнению с обращениями к дискам, тем быстрее она реагирует на запросы. Конечно, по мере сокращения ввода-вывода загрузка процессора также сокращается, что повышает эффективность системы.

<br/>

### Понятие о главной памяти

Все компьютеры используют память, которая в действительности состоит из иерархии различных уровней памяти. В сердце иерархии находится главная память (main memory), которая содержит все исполняемые инструкции и манипуляции данными. Вся главная память представляет собой память произвольного доступа (RAM), что означает возможность чтения байта из любого ее участка за одно и то же время. Обычно вы имеете доступ к данным в главной памяти за 10-100 наносекунд.

Важная часть информации Oracle, хранимой в выделенной ему RAM, составляет программный код, выполняющийся в данный момент или выполнявшийся только что. Если новый пользовательский процесс нуждается в том же коде, он доступен ему в памяти в скомпилированном виде, что значительно ускоряет время его выполнения. Области памяти также содержат информацию о том, какие пользователи заблокировали определенную таблицу, тем самым повышая эффективность коммуникаций между разными сеансами. Но наиболее важно, наверное, то, что области памяти помогают в обработке данных, находящихся в постоянном дисковом хранилище. Oracle не проводит непосредственных изменений в данных на диске: данные всегда читаются с диска, удерживаются в памяти и изменяются там перед тем, как быть переданными обратно на диск.

Для обозначения этих участков памяти принято использовать термин буферы. Буферы памяти – это постраничные области памяти, в которые Oracle передает содержимое дисковых блоков. Если база данных нужно прочесть (выбрать) или обновит данные, она копирует соответствующие блоки с диска в буферы памяти. После проведения необходимых изменений, Oracle переносит содержимое буферов памяти на диск.

Oracle использует два типа структур памяти – общую и относящуюся к процессу. Системная глобальная область (system global area – SGA) – это часть общей памяти, которую разделяют между собой все серверные процесс (включая фоновые). Специфичная для процессов часть памяти известна как программная глобальная область (program global area - PGA), или принадлежащая процессу память (process-private memory). В последующих разделах мы рассмотрим эти два компонента памяти Oracle более подробно.

<br/>

### Системная глобальная область

SGA – наиболее важный компонент памяти в экземпляре Oracle. Особенно в крупных OLTP-базах данных SGA намного больше и важнее, чем PGA. В средах хранилищ данных, с другой стороны, PGA может быть более важно область памяти Oracle – ввиду ее решающего влияния на эффективность сортировок и хеширования больших объемов данных, что присуще аналитическим вычислениям в хранилищах данных.

Назначение SGA состоят в ускорении производительности запросов и обеспечении большого объема параллельной активности. Поскольку обработка в памяти намного быстрее дискового ввода-вывода, размер SGA – один из важнейших конфигурационных параметров при настройке базы данных на достижение оптимальной производительности. Когда вы запускаете экземпляр Oracle, он занимает определенный объем памяти из оперативной памяти операционной системы и этот объем определяется компонентом SGA в инициализационном файле. Когда экземпляр останавливается, память, использованная SGA, возвращается операционной системе.

SGA не является однородной областью. На самом деле это комбинация нескольких структур памяти.

Как минимум SGA включает следующие структуры данных:

<ul>
<li>buffer cache</li>
<li>log buffer</li>
<li>shared pool:</li>
<li>- library cache</li>
<li>- data dictionary cache</li>
<li>- PL/sQL area</li>
<li>- SQL query and PL/SQL function result caches</li>
</ul>

<br/><br/>

Она также может включать:
<br/><br/>

<ul>
	<li>large pool</li>
	<li>java pool</li>
	<li>streams pool</li>
</ul>

<br/><br/>

Ниже перечислены основные компоненты SGA.

<br/><br/>

<ul>
<li>
Буферный кэш базы данных. Хранит копии блоков данных, прочитанных из файлов данных.
</li>
<li>
Разделенный пул. Содержит библиотечный кэш для хранения разобранного SQL и PL/SQL кода, готового к использованию всеми пользователями. Он также содержит кэш словаря данных, который хранит всю информацию словаря.
</li>
<li>
Буфер журнала повторного выполнения. Содержит информацию, необходимую для восстановления изменений, проведенных в базе данных операциями DML (языка манипулирования данными). Эта информация затем записывается в журналы повторного выполнения писателем журналов.
</li>
<li>
Пул Java. Представляет пространство «кучи» для создания объектов Java.
</li>
<li>
Большой пул. Хранит крупные выделения памяти, такие как резервные буферы RMAN.
</li>
<li>
Пул потоков. Поддерживает средство Oracle Streams (средство для репликации данных между базами данных).
</li>
</ul>

Когда вы запускаете экземпляр Oracle, он выделяет память по мере необходимост идо тех пор, пока не достигнет значения инициализационного параметра MEMORY_TARGET, который устанавливает общий лимит выделения памяти. Если объем выделенной памяти уже составляет MEMORY_TARGET , вы не сможете динамически увеличить объем любого компонента памяти, не уменьшая объема какого-либо другого. Oracle позволяет перемещать память от одного динамически выделяемого компонента к другому.

Например, вы можете увеличить память, выделенную буферному кэшу, взяв ее из разделяемого пула. Если у вас запланирован запуск некоторого задания на определенное время дня, вы можете написать простой сценарий, выполняемый перед запуском задания, который модифицирует выделение памяти среди различных компонентов. После завершения задания можете запустить другой сценарий, который вернет распределение памяти обратно к исходным установкам.

В следующих нескольких разделах мы обсудим различные компоненты SGA. Вы может управлять SGA самостоятельно, выполняя калибровку памяти, выделяемой экземпляру Oracle, с изменением требований к памяти работающего экземпляра. Однако лучший способ управления SGA (так же, как и PGA) состоит просто в адаптации менеджмента памяти.

<br/>

### Буферный кэш базы данных

Буферный кэш базы данных состоит из буферов памяти, которые Oracle использует для хранения данных, прочитанных серверным процессом из файлов данных на диске в ответ на запросы пользователей. Доступ к буферному кэшу, конечно же, осуществляется намного быстрее, чем чтение данных из дискового хранилища. Когда пошльзовательмодифицирует данные, эти изменения проводятся также в буферном кэше базы данных. Поэтому буферный кэш содержит как оригинальные блоки, прочитанные с диска, так и измененные блоки, которые подлежат записи на диск.

Буферы памяти в буферном кэше базы данных можно разделить на три группы:

<br/>

<ul>
<li>
Свободные буферы. Это буферы, которые не содержат полезных данных, и потому база данных может использовать их для хранения данных, прочитанных с диска.
</li>
<li>
Грязные буферы. Здесь хранятся данные, которые были прочитаны с диска и затем модифицированы, но еще не записаны в файлы данных на диске.
</li>
<li>
Занятые (pinned) буферы. Это буферы данных, находящиеся в активном использовании пользовательским сеансом.
</li>
</ul>

<br/>

Когда пользовательский процесс запрашивает данные, Oracle сначала проверяет наличие этих данных в буферном кэше. Если они там, то серверный процесс читает эти данные непосредственно из SGA и отправляет пользователю. Если данные не найдены в буферном кэше, серверный процесс читает их из соответствующих файлов данных на диске и помещает в буферный кэш базы данных. Конечно, при этом должны быть свободные буферы, доступные в буферном кэше, чтобы данных о том, чтобы он записал некоторые грязные буферы на диск, освободив тем самым место для новых данных.

Oracle поддерживает список LRU свободных, занятых и «грязных» буферов в памяти. В обязанности процесса писателя базы данных входит запись грязных буферов на диск, чтобы обеспечить постоянное наличие свободных буферов в буферном кэше базы данных. Чтобы определить, какие грязные буферы подлежат записи на диск, Oracle использует модифицированный алгоритм LRU, который гарантирует присутствие в буферном кэше только наиболее свежих данных. Запись на диск данных, которые в данный момент не запрашиваются, повышает производительность базы данных.

Чем больше буферный кэш, тем меньше требуется операций записи чтения и выше производительность базы данных. Таким образом, правильное определение размера буферного кэша очень важно для производительности вашей базы данных. Конечно, простое назначение чрезвычайно большого буферного кэша может повредить производительности, потому что вы можете занять больше памяти, чем необходимо и тем вызвать нежелательный своппинг на вашем сервере.

<br/>

### Использование нескольких пулов буферных кэшей базы данных

Обычно простого буферного кэша по умолчанию достаточно для обслуживания памяти экземпляра. Назначение одного и того же буферного кэша всем объектам базы данных может быть иногда не слишком эффективным, потому что разные объекты и различные типы данных могут иметь разные требования к длительности их пребывания в кэше данных. Например, к таблице А могут выполняться сотни тысяч обращений в день, в то время как к таблице В – только два обращения в день. Ясно, что имеет смысл оставить таблицу А в буферном кэше на весь день, чтобы повысить скорость обращений, а таблицу В удалять оттуда каждый раз после использования, чтобы сэкономить место в кэше.

Oracle обеспечивает гибкость в использовании буферного кэша, позволяя конфигурировать буферный кэш базы данных в множество буферных пулов. Буферные пулы в этот контексте - это просто части общего буферного кэша, отвечающие данным критериям удержания объектов базы данных данных вроде таблиц. Например, вы можете взять общий буферный кэш размером в 500 Мбайт и разделить его на три пула – два по 200 Мбайт и один в 100 Мбайт. Как только вы создадите данные буферные пулы, то сможете назначать им таблицы при создании для исключительного использования. Вы можете также применят команду ALTER TABLE или ALTER INDEX для модификации типа буферного пула, который должна использовать таблица или индекс.

Обратите внимание, что любым объектам базы данных, которым вы не назначаете определенный постоянный (keep) или повторно используемый (recycle) буферный пул, будут назначены в буферный пул по умолчанию, размер которого определен в соответствие со значением, указанным в параметре инициализации DB_CACHE_SIZE. Постоянный или повторно используемый буферные пулы необязательны, в то время как буферный пул по умолчанию – обязателен.

Помните, что главной целью назначения объектов в разные буферные пулы является минимизация «промахов» при обращении к кэшу данных и как следствие – минимизация операций дискового ввода-вывода. Фактически все стратегии буферного кэширования нацелены на это. Если вы не знаете, какие объекты в вашей базе данных к каким типам буферных кэшей отнести, запросите эту информацию из представления V$DB_CACHE_ADVICE, чтобы получить совет у Oracle.

Основные типы буферных пулов.

<br/><br/>

<table>
<tr>
<td> Буферный пул</td>
<td> Инициализационный параметр</td>
<td> Описание </td>

</tr>

<tr>
<td> Постоянный буферный пул (keep buffer pool)</td>
<td> DB_KEEP_CACHE_SIZE </td>
<td> Постоянно хранит блоки данных в памяти. У вас могут быть маленькие таблицы, к которым выполняются частые обращения и для предотвращения их удаления из буферного кэша им можно назначить постоянный буферный пул при создании таблицы.
 </td>

</tr>
<tr>
<td> Повторно используемый буферный пул (recycle buffer pool)</td>
<td> DB_RECYCLE_CACHE_SIZE </td>
<td> Удаляет данные из кэша немедленно после использования. Этот буферный пул следует применять осторожно, если вы вообще решите использовать его. Повторно используемый буферный пул удаляет объект из кэша сразу по завершении транзакции. Очевидно, что его следует применять только для крупных таблиц, обращение к которым осуществляется нечасто, и которые не нужно хранить к кэше неопределенно долго. </td>

</tr>
<tr>
<td> Буферный пул по умолчанию (default buffer pool)</td>
<td> DB_CACHE_SIZE </td>
<td> Содержит все данные и объекты, которые не назначены в постоянный и повторно используемый буферные пулы. </td>

</tr>

</table>

<br/>
<h3> Множественные размеры блоков базы данных и буферный кэш</h3>

Вы можете иметь множественные размеры блоков и вазе данных. Сначала потребуется выбрать стандартный размер блока, а затем определить до четырех других нестандартных размеров.

Параметр DB_BLOCK_SIZE в файле параметров инициализации определяет ваш стандартный и часто единственный размер блока для свей базы данных. Параметр DB_CAHCE_SIZE в вашем файле инициализационных параметров специфицирует размер (в байтах) кэша буферов со стандартным размером блоков. Обратите внимание, что вы не устанавливаете количество буферов базы данных, вместо этого вы специфицируете размер самого буферного кэша в параметре DB_CACHE_SIZE.

Вы можете иметь до пяти различных размеров блока в своих базах данных, т.е. можно создавать табличные пространства с одним из пяти доступных размеров блоков. Хотя большинство баз данных используют единственный стандартный размер блока. Хотя большинство баз данных используют единственный стандартный размер блока (такой как 4 Кбайт, 8 Кбайт или 16 К байт), можно также указать некоторые или все размеры четырех нестандартных блоков. Например, можно иметь некоторые таблицы типа хранилища данных, которые выиграют от крупного размера блока, например 32 Кбайт. Однако при этом большитсвто прочих таблиц в базе могут обслуживать нужды онлайновой обработки, и потому должны использовать стандартный размер блока в 4 Кбайт. Если вам случиться использовать все четыре из нестандартных размеров блока помимо стандартного, можете создать табличные пространства со всеми пятью размерами блоков. Однако прежде чем вы создадите эти табличные пространства с нестандартным размером блоков, вы должны сконфигурировать нестандартные подкэши в буферных кэшах для каждого размера блока, который хотите использовать. Специфицировать нестандартные буферные подкэши можно с помощью параметра инициализации DB_nK-CACHE_SIZE, где n- размер блока в Кбайт, который может принимать значения 2,4,8,16 или 32.

Как видите буферный кэш базы данных может быть разделен на три пула: пул по умолчанию, постоянный и повторно используемый. Общий размер буферного кэша составит сумму блоков памяти, назначенных всем компонентам буферного кэша базы данных. Постоянный и повторно используемый буферные пулы могут быть созданы со стандартным размером блока, а для буферного пула по умолчанию можно использовать до четырех других размеров блока.

Приведем пример, демонстрирующий то, как специфицировать в инициализационном файле различные значения для каждого из подкэшей буферного кэша. В этом примере числа справа показывают размер памяти, выделенной для определенного типа буферного кэша.

DB*KEEP_CACHE_SIZE = 48MB<br/>
DB_RECYCLE_CACHE_SIZE = 24MB<br/>
DB_CACHE_SIZE = 128MB /* Стандартный размер блока 4 Кбайт _/<br/>
DB_2k_CACHE_SIZE = 48MB /_ нестандартный размер блока 2 Кбайт _/<br/>
DB_8k_CACHE_SIZE = 192MB /_ нестандартный размер блока 8 Кбайт _/<br/>
DB_16k_CACHE_SIZE = 384MB /_ нестандартный размер блока 16 Кбайт \_/<br/>

Общий размер буферного кэша в этом примере составит сумму все приведенных поэкэшей, равную 824 Мбайт.

<br/>

### Коэффициент попаданий в буферный кэш

Чтение из буфера происходит намного быстрее, чем чтение с диска. Важнейший принцип правильного определения размера буферного кэша можно сформулировать одной фразой: «затрагивать как можно меньшее количество блоков», поскольку дисковый ввод-вывод, необходимый для чтения данных из блоков Oracle на диске, обходится много дороже чтения данных из SGA. Вот почему коэффициент попаданий (hit ratio), измеряющий процент времени, когда пользователь получает нужные ему данные из буферного кэша (вместо чтения диска), является настолько важным индикатором производительности экземпляра Oracle.

Коэффициент попаданий буферного кэша вычисляется следующим образом.

Коэффициент попаданий = (1- (физических чтений) / (логических чтений) \* 100)

В этой формуле физические и логические чтения (чтения с диска и из памяти, соответственно) накапливаются с момента запуска экземпляра Oracle. Поэтому если вы вычисляете коэффициент в понедельник утром после перезапуска базы в ночь на воскресенье, он даст очень низкое значение. По мере того, как минуют дни недели, значение коэффициента может значительно возрасти, потому что происходит все больше запросов на чтение, и oracle удовлетворяет их, извлекая данные, уже находящиеся в памяти.

К сожалению, Oracle не предлагает никаких надежных правил или руководств относительно того, сколько памяти вы должны выделить для буферного кэша в SGA. Вы можете получить представление об оптимальном размере методом проб и ошибок.

Высокий коэффициент попаданий в буферный кэш не всегда связан с высокой производительностью базы данных. Вполне возможно, что ваша база будет демонстрировать очень высокий показатель попаданий – скажем, 90% - и, тем не менее, иметь проблемы с производительностью. Например, несмотря на высокое общее число логических чтений и значение коэффициента попаданий, ваши SQL – запросы могут быть неэффективными.

<br/>

### Разделяемы пул

Разделяемы пул (share pool) очень важная часть Oracle SGA, и правильное определение его размера для вашего экземпляра поможет устранить несколько типов узких мест в экземпляре Oracle. В отличие от буферного кэша базы данных, который хранит действительные блоки данных, разделяемый пул хранит исполняемый код PL/SQL и операторы SQL вместе с информацией, относящейся к таблицам словаря данных. Словарь данных – это набор ключевых таблиц, поддерживаемых Oracle и содержащих важнейшие данные о таблицах базы, пользователях, привилегиях и тому подобном.

Правильное определение размера области разделяемого пула обеспечивает преимущества в двух отношениях. Во-первых, ваше время реакции базы будет меньше, потому что вы сокращаете время обработки – если не нужно перекомпилировать один и тот же код Oracle всякий раз, когда пользователь выполняет запрос, экономится время. Oracle повторно использует ранее скомпилированный код, если встречает его снова. Во-вторых, больше пользователей могут использовать систему, потому что повторное применение кода позволяет базе данных обслуживать больше пользователей с теми же ресурсами. Как объем ввода-вывода, так и загрузка процессов существенно сокращаются, когда ваша база данных эффективно использует память из разделяемого пула.

Далее мы поговорим о библиотечном кэше и кэше словаря данных, оба они являются составными частями разделяемого пула.

<br/>

### Библиотечный кэш

Код приложения – будь то простой код SQL, встроенный в форме программных единиц PL/SQL, таких как процедуры и пакеты – сначала анализируется, а выполняется позднее. Oracle сохраняет все скомпилированные операторы SQL в компоненте разделяемого пула под названием библиотечный кэш. Этот компонент пула разделяется всеми пользователями базы данных. Каждый раз при выдаче SQL оператора Oracle сначала проверяет библиотечный кэш на предмет наличия в нем уже проанализированного и готового к выполнению этого оператора. Если он там, то Oracle использует версию из библиотечного кэша, существенно сокращая время обработки. Это называется мягким разбором (soft parse).

Если Oracle не находит в библиотечном кэше готовой к выполнению версии кода SQL, значит она должна быть построена заново – это называется жестким разбором (hard parse). Oracle использует часть памяти библиотечного кэша для хранения вновь разобранного кода. Если для этого недостает памяти в разделяемом пуле, то Oracle вытесняет из него самый старый код, чтобы освободить место для нового.

Весь жесткий разбор включает использование критичных системных ресурсов, таких как мощь процессора, и внутренних структур Oracle, подобных зашелкам (latches); вы должны предпринят все возможное, чтобы сократить количество таких ситуаций. Большое число случаев жесткого разбора ведет к конкуренции за ресурсы и последующего замедлению работы базы данных при ответе на пользовательские запросы.

Вы должны принять решение касательно размера библиотечного кэша на основе коэффициента попаданий и промахов. Если ваша система показывает более, чем нормальное количество промахов (это означает частый повторный разбор или перезапуск кода), самое время увеличить размер библиотечного кэша. Способ сделать это состоит в расширении разделяемого пула.

Отсутствие нужной информации в кэше словаря данных или в библиотечном кэше разделяемого пула сильнее отражается на производительности базы данных, чем отсутствие ее в кэше буферного пула. Например, сокращения коэффициента попаданий в кэш словаря данных с 99% до 89% ведет к более ощутимому снижению производительности, чем аналогичное снижение коэфициента в буферном кэше.

<br/>

### Кэш результатов

В Oracle Database 11G появился замечательный новый компонент SGA, именуемый кэшем результатов (result cache). Кэш результатов – ото область SGA, именуемый кэшем результатов (result cache). Кэш результатов – это область SGA, где база данных хранит результаты как запросов SQL, так и функций PL/SQL, если вы включаете эти кэши. Когда база данных выполняет некоторый запрос SQL вновь, она может просто извлечь результат из кэша результата в вместо повторного выполнения того же запроса, тем самым существенно повышая производительность. Кэширование результата функций PL/SQL работает очень похоже на кэш результатов запросов SQL. Когда кэшированная функция выполняется повторно, база данных не выполняет ее тело вновь, а вместо этого просто сразу возвращает кэшированные результат.

Вы используете инициализационный параметр RESULT_CACHE_MODE, чтобы контролировать поведение кэширования базой данных результатов запросов SQL и функций PL/SQL. Можно также использовать подсказку нового кэша результатов, чтобы переопределить установку параметра RESULT_CACHE_MODE. Управлять кэшированием можно через PL/SQL пакет DBMS_RESULT_CACHE или с помощью Enterprise Manager.

<br/>

### Буфер журнала повторного выполнения

Буфер журнала повторного выполнения по размеру обычно не превышает пары мегабайт в отличие от размера буферного кэша и разделяемого пула, но, тем не менее, является важнейшим компонентом SGA. Когда серверный процесс изменяет данные в кэше буфера данных (через вставку, удаление или обновление), он генерирует данные повторного выполнения, которые записываются в буфер журнала повторного выполнения. Процесс-писатель журнала записывает эту информацию из буфера в памяти в файлы журнала повторного выполнения на диске.

Для установки размера буфера журнала повторного выполнения используется инициализационный параметр LOG_BUFFER, и он остается фиксированным на протяжении существования экземпляра. То есть, размер буфера журнала повторного выполнения динамически изменять нельзя, в отличие от других компонентов SGA.

Процесс-писатель журналов пишет содержимое буфера журнала повторного выполнения на диск в любом из перечисленных ниже случаев.

<ul>
<li>
Буфер журнала повторного выполнения заполнен на треть
</li>
<li>
Пользователь фиксирует транзакцию
</li>
<li>
Буферный кэш базы данных имеет мало свободного места и нуждается в записи измененных данных в журнал повторного выполнения. Писатель базы данных инструктирует процесс-писатель журнала о необходимости сброса содержимого буферов журнала на диск для освобождения места для новых данных.
</li>
</ul>

Буфер журнала повторного выполнения цикличен – процесс-писатель журнала пишет записи повторного выполнения из буфера в файлы журнала повторного выполнения, а серверный процесс записывает новые элементы журнала повторного выполнения в буфер поверх сброшенных в файлы журнала. База данных выдает небольшой объем памяти – 5 Мбайт или около того - для буфера журнала повторного выполнения. Большой размер этого буфера снизит производительность ввода-вывода файла журнала (особенно если у вас большие или многочисленные транзакции), но ваши фиксации также займут больше времени.

Процесс-писатель журнала повторного выполнения обычно выполняет запись в файлы журнала очень быстро, даже в случае высокой загрузки. Слишком маленький буфер журнала повторного выполнения приводит к высокой загрузке процесса-писателя – получается, что он постоянно пишет на диск. Более того, если буфер журнала слишком мал, он часто переполняется, принимая новые элементы журнала повторного выполнения.

Oracle предлагает опцию под названием nologging, которая позволяет вам полностью миновать журнализацию повторного выполнения и избежать конкуренции во время некоторых операций (таких как загрузка большого объема данных). Вы можете также сложить фиксации в одно длинное задание, позволив журналам повторного выполнения более эффективно выполнить запись.

<br/>

### Большой пул и Java-пул

Большой пул (large pool) – это просто необязательный пул памяти, которым Oracle управляет иначе, чем разделяемый пулом. Большой пул понадобится конфигурировать только в том случае, если вы используете в базе данных параллельные запросы. Oracle также рекомендует конфигурировать этот пул, если вы применяете RMAN или конфигурацию разделяемого сервера вместо стандартной конфигурации выделенного сервера. Вы устанавливаете размер этого пула в инициализационном файле, используя параметр LARGE_POOL_SIZE. Большой пул памяти важен, если применяется архитектура разделяемого сервера.

Пул Java (устанавливаемый параметром JAVA_POOL_SIZE) предназначен для баз данных, которые содержат много кода Java, так что обычной области SGA недостаточно для размещения компонентов, использующих объекты Java. Пул памяти java резервируется для виртуальной машины Java (JVM) и для ваших приложений Java. В случае развертывани яEnterprise JavaBeans или применения CORBA потенциально понадобится размер пула java свыше 1 Гбайт.

<br/>

### Пул Streams

Oracle Streams – это технология, которая позволяет разделять общие данные между разными базами данных и между разными средами приложений. Пул Stream – это память, выделенная для поддержки деятельности Streams в вашем экземпляре. Если вы вручную устанавливаете копоенет пула Streams, используя инициализационный параметр STREAMS_POOL_SIZE, память для этого пула передается из буферного кэша после первого обращения к Streams. Если вы используете автоматическое управление памятью, то память для пула Streams заимствуется из глобального пула SGA. Переданный объем составляет до 10% от размера разделяемого пула.

<br/>

### Программная глобальная область

Oracle создает программную глобальную область (PGA) для каждого пользователя при открытии пользовательского сеанса. Эта область содержит данные и управляющую информацию для выделенного серверного процесса, который Oracle создает для каждого индивидуального пользователя. В отличие от SGA, PGA предназначена для исключительного использования каждый серверным процессом и не может разделяться между несколькими процессами. Регистрационная информация сеанса и постоянная информация, такая как информация о привязке переменных и соглашениях о типах данных, по–прежнему является частью SGA, если только вы не применяете конфигурацию разделяемого сервера но область времени выполнения, используемая операторами SQL располагается в PGA.

Например, пользовательский процесс может иметь некоторые курсоры (дескрипторы областей памяти, где вы храните значения переменных), ассоциированные с ним. Поскольку это пользовательские курсоры, они не разделяются автоматически с другими пользователями и потому PGA – подходящее место для хранения этих частных значений. Другое основное использование PGA ориентировано на выполнение требовательных к памяти операций SQL, которые включают сортировку, таких как запросов с конструкцией ORDER BY или GROUP BY. Таким операциям нужна некоторая рабочая область, и PGA обеспечивает эту область памяти.

Память PGA относится к следующим двум типам:

<ul>
<li>
Частная область SQL. Эта область памяти содержит информацию о привязке переменный SQL и структуры памяти времени выполнения. Каждый сеанс, выполняющий оператор SQL, получает свою собственную частную область SQL.
</li>
<li>
Область времени выполнения. Область времени выполнения создается для пользовательского сеанса, когда тот выдает оператор SELECT, INSERT, UPDATE или DELETE. После запуска оператора SELECT, INSERT, UPDATE или DELETE либо после извлечения результатов оператора SELECT область времени выполнения освобождается Oracle.
</li>

</ul>

Если пользовательский сеанс использует сложные соединения или интенсивную сортировку (группировку и упорядочивание), то сеанс использует область времени выполнения для выполнения таких ресурсоемких по памяти операций.

Чтобы сократить время реакции, все сортировки, выполняемые в PGA, должны полностью проходить в кэше рабочей области. Это называется операцией оптимального режима (optimal mode operation), поскольку вся работа выполняется в памяти, без дискового ввода-вывода. Если сортировка требует обращения к диску, поскольку области памяти для нее недостаточно, это сильно замедляет операцию сортировки. Операция SQL, которая вынуждена обращаться к дисковой памяти даже в ограниченной степени – однопроходная операция – происходит медленнее, чем операция, полностью выполняемая в области памяти. Однако если ваша область памяти времени выполнения слишком мала по сравнению с потребностями операции сортировки. Oracle приходится осуществлять несколько проходов по сортируемым данным, что очень нагружает диск и значительно увеличивает время реакции для пользователя. Таким образом, существует прямая зависимость между размером PGA и производительность запросов.

Вы можете настраивать размеры этих частных рабочих областей, но это подход «наудачу», который требует учета множества сложных конфигурационных параметров Oracle, касающихся рабочих областей памяти. К параметрам, которые нужно устанавливать вручную, относятся SORT_AREA_SIZE, HASH_AREA_SIZE и BITMAP_AREA_SIZE.

Сумма всей памяти PGA, используемой всеми сеансами, составляет объем PGA, используемый экземпляром. Oracle рекомендует применять автоматическое управление PGA, которое автоматизирует выделение памяти PGA. Это помогает более эффективно использовать память, выделенную базе данных. Это средство ведет себя особенно хорошо при высокой рабочей нагрузке, потому что динамически исправляет границы доступной памяти и постоянно отслеживает ситуацию. Ручное управление PGA может привести либо к слишком малому, либо к чересчур большому выделению памяти, что чревато проблемами производительности.

Вы автоматизируете выделение памяти PGA, устанавливая параметр инициализации WORKAREA_SIZE_POLICY в его значение по умолчанию – auto. Если вы установите значение этого параметра в manual, то должны будете специфицировать все параметры рабочей области PGA, упомянутые выше. Параметр WORKAREA_SIZE_POLICY гарантирует автоматизацию памяти PGA. Однако вы должны также установить размер общей выделенной памяти PGA, указав значение инициализационного параметра PGA_AGGREGATE_TARGET. Например, если вы установите в файле параметров инициализации PGA_AGGREGATE_TARGET=5000000000, то Oracle использует 5 Гбайт выделенной памяти PGA в качестве глобальной установки для экземпляра. Oracle будет удерживать общий объем памяти PGA, используемой всеми серверными процессами экземпляра, в пределах этой величины.

Если вы не установите параметр PGA_AGGREGATE_TARGET, то должны будете использовать ручной режим управления рабочими областями. В качестве альтернативы можно активизировать ручной режим, установив параметр WORKAREA_SIZE_POLICY в manual. Oracle настоятельно рекомендует применять автоматическое управление PGA, поэтому что оно позволяет более эффективно использовать память. Для пользователей это означает более высокую производительность и сокращение времени выполнения запросов в целом.

Когда вы используете автоматическое управление памятью PGA, установив параметр PGA_AGGREGATE_TARGET. Oracle старается выделить достаточно памяти всем рабочим областям в оптимальной манере, выполняя все требовательные по памяти операции SQL в памяти кэша. В Худшем случае некоторые рабочие области используют дисковое пространство во однопроходном режиме. Однако если вы устанавливаете слишком малое значение параметра PGA_AGGREGATE_TARGET относительно рабочей области, необходимой вашему экземпляру, то Oracle начинает многопроходное выполнение операций SQL с интенсивной сортировкой или хешированием, что влечет за собой катастрофические последствия для производительности экземпляра.

В режиме ручного управления вся память PGA, которая не была использована, автоматически возвращается системе. Каждому сеансу, подключаемому к базе данных, выделяется определенный объем памяти PGA, который удерживается до завершения сеанса, независимо от того, выполняются в нем операторы SQL или нет. При автоматическом управлении PGA сервер Oracle возвращает всю неиспользуемую память PGA операционной системы. В загруженной среде это приводит к огромной разнице в производительности базы данных и системы. Предположим, что вы установили параметр PGA_AGGREGATE_TARGET в 5 Гбайт. Oracle не станет немедленно захватывать 5 Гбайт памяти при запуске экземпляра, как это происходит с параметром SGA_TARGET. Он заимствует память у операционной системы по мере необходимости, до достижения лимита в 5 Гбайт. Как только сеанс освободит выделенную ему область памяти, эта память немедленно возвращается операционной системе.

<br/>

### Автоматическое управление памятью

В прежних версиях Oracle администраторы тратили довольно много времени на подбор правильного размера SGA. Ничего необычного не было в том, чтобы довольно часто выполнять перекалибровку размера SGA, добиваясь оптимальной настройки экземпляра. В Oracle Database 11g вы можете конфигурировать автоматическое управление памятью, используя новый параметр инициализации MEMORY_TAGRET. Все, что необходимо сделать для этого – это присвоить определенное значение параметру MEMORY_TARGET, и Oracle возьмет на себя автоматическое распределение памяти между компонентами SGA и PGA. Выделение памяти SGA Oracle различным компонентам происходит не статически, а меняется по мере изменения загрузки базы данных. Oracle может автоматически управлять следующими пятью компонентами SGA (соответствующие инициализационные параметры Oracle указаны в скобках):

<ul>
<li>
Буферный кэш базы данных (DB_CACHE_SIZE);
</li>
<li>
Разделяемы пул (SHARED_POOL_SIZE);
</li>
<li>
Большой пул (LARGE_POOL_SIZE);
</li>
<li>
Пул Java (JAVA_POOL_SIZE);
</li>
<li>
Пул потоков (STREAMS_POOL_SIZE);
</li>
</ul>

Как видите, Oracle автоматически настраивать пять компонентов SGA, которые мы называем параметрами SGA с автоматически устанавливаемым размером. Вы должны по-прежнему самостоятельно управлять остальными компонентами SGA, даже при автоматическом управлении памятью.

Ниже приведены настраиваемые вручную компоненты SGA:

<ul>
<li>
Постоянный буферный кэш (DB_KEEP_CACHE_SIZE);
</li>
<li>
Повторно используемый буферный кэш (DB_RECYCLE_CACHE_SIZE);
</li>
<li>
Все буферные кэши нестандартного размера блока (DB_nK_CACHE_SIZE);
</li>
<li>
Буфер журнала повторного выполнения (LOG_BUFFER).
</li>
</ul>

Обратите внимание, что первые три компонента в этом списке необязательны. Как администратор базы данных, вы должны установить значения всех ручных компонентов SGA.

<br/>
<h3> Опции управления памятью и умолчания в инсталляции базы данных</h3>

Когда вы создаете базу данных с помощью DataBase Configuration Assistant (DBCA) и если выбираете базовую опцию инсталляции, то автоматическое управление памятью включено по умолчанию. Если же вместо этого вы предпочтете расширенную опцию инсталляции, нужно будет выбрать одну из следующих трех конфигураций памяти:

<ul>
<li>
Автоматическое управление памятью;
</li>
<li>
Автоматическое управление разделяемой памятью плюс автоматическое управление памятью PGA;
</li>
<li>
Ручное управление разделяемой памятью плюс автоматическо еупрвление памятью PGA.
</li>
</ul>

Если вы создает базу данных оператором CREATE DATABASE и не указываете никаких инициализационных параметров, связанных с управлением памятью, то по умолчанию принимается ручное управление разделяемой памятью. Для PGA конфигурацией по умолчанию будет автоматическое управление памятью.
